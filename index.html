<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PowerShell Drive Mapping Script Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-lg">
        <h1 class="text-2xl font-bold mb-4 text-center">Generate PowerShell Drive Mapping Script</h1>
        <div class="mb-4">
            <label class="flex items-center">
                <input type="checkbox" id="removeAllDrives" class="mr-2">
                <span class="text-sm font-medium text-gray-700">Remove all existing drive mappings</span>
            </label>
        </div>
        <div id="mappings" class="space-y-4">
            <div class="mapping border p-4 rounded-md">
                <div class="mb-4">
                    <label for="driveLetter_0" class="block text-sm font-medium text-gray-700">Drive Letter</label>
                    <input type="text" id="driveLetter_0" placeholder="e.g., G" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                </div>
                <div class="mb-4">
                    <label for="networkPath_0" class="block text-sm font-medium text-gray-700">Network Path</label>
                    <input type="text" id="networkPath_0" placeholder="e.g., \\srvdc01.company.local\company\share" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                </div>
                <div class="mb-4">
                    <label for="groupName_0" class="block text-sm font-medium text-gray-700">Group Name (Optional)</label>
                    <input type="text" id="groupName_0" placeholder="e.g., Domain Users" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                </div>
                <div class="mb-4">
                    <label for="profileName_0" class="block text-sm font-medium text-gray-700">Network Profile</label>
                    <select id="profileName_0" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="DomainAuthenticated" selected>DomainAuthenticated</option>
                        <option value="Public">Public</option>
                        <option value="Private">Private</option>
                    </select>
                </div>
                <div class="mb-4">
                    <label for="domainSuffix_0" class="block text-sm font-medium text-gray-700">Domain Suffix (Optional)</label>
                    <input type="text" id="domainSuffix_0" placeholder="e.g., company.local" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                </div>
                <button onclick="removeMapping(this)" class="text-red-500 hover:text-red-700 text-sm">Remove Mapping</button>
            </div>
        </div>
        <button onclick="addMapping()" class="mt-4 w-full bg-green-500 text-white p-2 rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500">Add Another Mapping</button>
        <button onclick="exportConfig()" class="mt-4 w-full bg-yellow-500 text-white p-2 rounded-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500">Export Config to JSON</button>
        <label for="importConfig" class="mt-4 w-full bg-purple-500 text-white p-2 rounded-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 inline-flex items-center justify-center cursor-pointer">
            Import Config from JSON
            <input type="file" id="importConfig" accept=".json" class="hidden" onchange="importConfig(this.files[0])" />
        </label>
        <button onclick="generateScript()" class="mt-4 w-full bg-blue-500 text-white p-2 rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500">Download PowerShell Script</button>
        <button onclick="generateIntuneScript()" class="mt-4 w-full bg-indigo-500 text-white p-2 rounded-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">Download Intune Script</button>
    </div>

    <script>
        let mappingCount = 1;

        function addMapping(data = {}) {
            const mappingsDiv = document.getElementById('mappings');
            const newMapping = document.createElement('div');
            newMapping.className = 'mapping border p-4 rounded-md mt-4';
            newMapping.innerHTML = `
                <div class="mb-4">
                    <label for="driveLetter_${mappingCount}" class="block text-sm font-medium text-gray-700">Drive Letter</label>
                    <input type="text" id="driveLetter_${mappingCount}" placeholder="e.g., G" value="${data.driveLetter || ''}" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                </div>
                <div class="mb-4">
                    <label for="networkPath_${mappingCount}" class="block text-sm font-medium text-gray-700">Network Path</label>
                    <input type="text" id="networkPath_${mappingCount}" placeholder="e.g., \\srvdc01.company.local\company\share" value="${data.networkPath || ''}" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                </div>
                <div class="mb-4">
                    <label for="groupName_${mappingCount}" class="block text-sm font-medium text-gray-700">Group Name (Optional)</label>
                    <input type="text" id="groupName_${mappingCount}" placeholder="e.g., Domain Users" value="${data.groupName || ''}" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                </div>
                <div class="mb-4">
                    <label for="profileName_${mappingCount}" class="block text-sm font-medium text-gray-700">Network Profile</label>
                    <select id="profileName_${mappingCount}" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="DomainAuthenticated" ${data.profileName === 'DomainAuthenticated' ? 'selected' : ''}>DomainAuthenticated</option>
                        <option value="Public" ${data.profileName === 'Public' ? 'selected' : ''}>Public</option>
                        <option value="Private" ${data.profileName === 'Private' ? 'selected' : ''}>Private</option>
                    </select>
                </div>
                <div class="mb-4">
                    <label for="domainSuffix_${mappingCount}" class="block text-sm font-medium text-gray-700">Domain Suffix (Optional)</label>
                    <input type="text" id="domainSuffix_${mappingCount}" placeholder="e.g., company.local" value="${data.domainSuffix || ''}" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                </div>
                <button onclick="removeMapping(this)" class="text-red-500 hover:text-red-700 text-sm">Remove Mapping</button>
            `;
            mappingsDiv.appendChild(newMapping);
            mappingCount++;
        }

        function removeMapping(button) {
            if (document.querySelectorAll('.mapping').length > 1) {
                button.parentElement.remove();
            } else {
                alert('At least one mapping is required.');
            }
        }

        function exportConfig() {
            const removeAllDrives = document.getElementById('removeAllDrives').checked;
            const mappings = [];
            for (let i = 0; i < mappingCount; i++) {
                const driveLetter = document.getElementById(`driveLetter_${i}`)?.value.trim();
                const networkPath = document.getElementById(`networkPath_${i}`)?.value.trim();
                const groupName = document.getElementById(`groupName_${i}`)?.value.trim();
                const profileName = document.getElementById(`profileName_${i}`)?.value;
                const domainSuffix = document.getElementById(`domainSuffix_${i}`)?.value.trim();

                if (driveLetter || networkPath || groupName || profileName || domainSuffix) {
                    mappings.push({ driveLetter, networkPath, groupName, profileName, domainSuffix });
                }
            }

            const config = { removeAllDrives, mappings };
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'drive_mapping_config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importConfig(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const config = JSON.parse(e.target.result);
                    if (!config || typeof config !== 'object') {
                        alert('Invalid JSON file.');
                        return;
                    }

                    // Set removeAllDrives checkbox
                    document.getElementById('removeAllDrives').checked = !!config.removeAllDrives;

                    // Clear existing mappings
                    const mappingsDiv = document.getElementById('mappings');
                    mappingsDiv.innerHTML = '';
                    mappingCount = 0;

                    // Add mappings from JSON
                    (config.mappings || []).forEach(mapping => {
                        if (mapping.driveLetter || mapping.networkPath || mapping.groupName || mapping.profileName || mapping.domainSuffix) {
                            addMapping({
                                driveLetter: mapping.driveLetter || '',
                                networkPath: mapping.networkPath || '',
                                groupName: mapping.groupName || '',
                                profileName: mapping.profileName || 'DomainAuthenticated',
                                domainSuffix: mapping.domainSuffix || ''
                            });
                        }
                    });

                    // Ensure at least one mapping exists
                    if (mappingCount === 0) {
                        addMapping();
                    }
                } catch (err) {
                    alert('Error parsing JSON file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function getDriveMappingScriptContent(mappings, removeAllDrives) {
            let scriptContent = `# Remove all existing drive mappings if specified
${removeAllDrives ? `
Get-PSDrive -PSProvider FileSystem | Where-Object { $_.DisplayRoot -like '\\\\*' } | ForEach-Object {
    try {
        Remove-PSDrive -Name $_.Name -Force -ErrorAction Stop
        Write-Host "Removed existing drive mapping: $($_.Name)"
    }
    catch {
        Write-Host "Failed to remove drive $($_.Name): $_"
    }
}
` : ''}# Define mappings
$mappings = @(
`;

            mappings.forEach((mapping, index) => {
                scriptContent += `    @{ DriveLetter = "${mapping.driveLetter}"; NetworkPath = "${mapping.networkPath}"; GroupName = "${mapping.groupName || 'Domain Users'}"; ProfileName = "${mapping.profileName}"; DomainSuffix = "${mapping.domainSuffix || ''}" }${index < mappings.length - 1 ? ',' : ''}\n`;
            });

            scriptContent += `)

foreach ($mapping in $mappings) {
    # Check if the network profile matches the specified profile
    $networkProfile = (Get-NetConnectionProfile).NetworkCategory
    if ($networkProfile -eq $mapping.ProfileName) {
        # Check domain suffix if specified
        $domainMatch = $true
        if ($mapping.DomainSuffix) {
            $adapters = Get-NetAdapter | Where-Object { $_.Status -eq 'Up' }
            $domainMatch = $false
            foreach ($adapter in $adapters) {
                $dnsConfig = Get-DnsClient | Where-Object { $_.InterfaceIndex -eq $adapter.InterfaceIndex }
                if ($dnsConfig -and $dnsConfig.ConnectionSpecificSuffix -eq $mapping.DomainSuffix) {
                    $domainMatch = $true
                    break
                }
            }
        }

        if ($domainMatch) {
            # Get the current user's domain and username
            $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
            $userName = $currentUser.Name
            $domain = $userName.Split('\\')[0]
            $sAMAccountName = $userName.Split('\\')[1]

            # Check if the user is a member of the specified group (case-insensitive)
            $group = $mapping.GroupName
            $isMember = (Get-ADUser -Identity $sAMAccountName -Server $domain | Get-ADPrincipalGroupMembership).Name -eq $group

            if ($isMember) {
                # Map the drive to the specified network share
                try {
                    New-PSDrive -Name $mapping.DriveLetter -PSProvider FileSystem -Root $mapping.NetworkPath -Persist -ErrorAction Stop
                    Write-Host "Drive $($mapping.DriveLetter): mapped successfully to $($mapping.NetworkPath)"
                }
                catch {
                    Write-Host "Failed to map drive $($mapping.DriveLetter):. Error: $_"
                }
            }
            else {
                Write-Host "User is not a member of '$group'. Drive $($mapping.DriveLetter): not mapped."
            }
        }
        else {
            Write-Host "Domain suffix does not match '$($mapping.DomainSuffix)'. Drive $($mapping.DriveLetter): not mapped."
        }
    }
    else {
        Write-Host "Network profile is not $($mapping.ProfileName). Drive $($mapping.DriveLetter): not mapped."
    }
}
`;
            return scriptContent;
        }

        function generateScript() {
            const removeAllDrives = document.getElementById('removeAllDrives').checked;
            const mappings = [];
            for (let i = 0; i < mappingCount; i++) {
                const driveLetter = document.getElementById(`driveLetter_${i}`)?.value.trim().toUpperCase();
                const networkPath = document.getElementById(`networkPath_${i}`)?.value.trim();
                const groupName = document.getElementById(`groupName_${i}`)?.value.trim();
                const profileName = document.getElementById(`profileName_${i}`)?.value;
                const domainSuffix = document.getElementById(`domainSuffix_${i}`)?.value.trim();

                if (!driveLetter || !networkPath) continue; // Skip incomplete mappings

                // Validate inputs
                if (!driveLetter.match(/^[A-Z]$/)) {
                    alert(`Invalid drive letter for mapping ${i + 1}. Please enter a single letter (e.g., G).`);
                    return;
                }
                if (!networkPath.match(/^\\\\[a-zA-Z0-9.-]+\\[^\\]+(\\[^\\]+)*$/)) {
                    alert(`Invalid network path for mapping ${i + 1}. Please enter a valid path (e.g., \\\\srvdc01.company.local\\company\\share).`);
                    return;
                }
                if (groupName && !groupName.match(/^[a-zA-Z0-9\s_-]+$/)) {
                    alert(`Invalid group name for mapping ${i + 1}. Use letters, numbers, spaces, underscores, or hyphens only.`);
                    return;
                }
                if (!['DomainAuthenticated', 'Public', 'Private'].includes(profileName)) {
                    alert(`Invalid profile name for mapping ${i + 1}. Please select a valid profile.`);
                    return;
                }
                if (domainSuffix && !domainSuffix.match(/^[a-zA-Z0-9.-]+$/)) {
                    alert(`Invalid domain suffix for mapping ${i + 1}. Use letters, numbers, dots, or hyphens only (e.g., company.local).`);
                    return;
                }

                mappings.push({ driveLetter, networkPath, groupName, profileName, domainSuffix });
            }

            if (mappings.length === 0) {
                alert('Please provide at least one valid mapping.');
                return;
            }

            const scriptContent = getDriveMappingScriptContent(mappings, removeAllDrives);

            // Create and download the file
            const blob = new Blob([scriptContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'MapDrives.ps1';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateIntuneScript() {
            const removeAllDrives = document.getElementById('removeAllDrives').checked;
            const mappings = [];
            for (let i = 0; i < mappingCount; i++) {
                const driveLetter = document.getElementById(`driveLetter_${i}`)?.value.trim().toUpperCase();
                const networkPath = document.getElementById(`networkPath_${i}`)?.value.trim();
                const groupName = document.getElementById(`groupName_${i}`)?.value.trim();
                const profileName = document.getElementById(`profileName_${i}`)?.value;
                const domainSuffix = document.getElementById(`domainSuffix_${i}`)?.value.trim();

                if (!driveLetter || !networkPath) continue; // Skip incomplete mappings

                // Validate inputs
                if (!driveLetter.match(/^[A-Z]$/)) {
                    alert(`Invalid drive letter for mapping ${i + 1}. Please enter a single letter (e.g., G).`);
                    return;
                }
                if (!networkPath.match(/^\\\\[a-zA-Z0-9.-]+\\[^\\]+(\\[^\\]+)*$/)) {
                    alert(`Invalid network path for mapping ${i + 1}. Please enter a valid path (e.g., \\\\srvdc01.company.local\\company\\share).`);
                    return;
                }
                if (groupName && !groupName.match(/^[a-zA-Z0-9\s_-]+$/)) {
                    alert(`Invalid group name for mapping ${i + 1}. Use letters, numbers, spaces, underscores, or hyphens only.`);
                    return;
                }
                if (!['DomainAuthenticated', 'Public', 'Private'].includes(profileName)) {
                    alert(`Invalid profile name for mapping ${i + 1}. Please select a valid profile.`);
                    return;
                }
                if (domainSuffix && !domainSuffix.match(/^[a-zA-Z0-9.-]+$/)) {
                    alert(`Invalid domain suffix for mapping ${i + 1}. Use letters, numbers, dots, or hyphens only (e.g., company.local).`);
                    return;
                }

                mappings.push({ driveLetter, networkPath, groupName, profileName, domainSuffix });
            }

            if (mappings.length === 0) {
                alert('Please provide at least one valid mapping.');
                return;
            }

            // Generate the drive mapping script content
            const driveMappingScript = getDriveMappingScriptContent(mappings, removeAllDrives);

            // Encode the drive mapping script to Base64
            const base64Script = btoa(driveMappingScript);

            // Generate the Intune script
            const intuneScriptContent = `
# Check if running in SYSTEM context
$currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
if ($currentUser -eq "NT AUTHORITY\\SYSTEM") {
    try {
        # Create the DriveMapper directory if it doesn't exist
        $scriptDir = "C:\\ProgramData\\DriveMapper"
        if (-not (Test-Path $scriptDir)) {
            New-Item -Path $scriptDir -ItemType Directory -Force | Out-Null
        }

        # Save the Base64-encoded drive mapping script to C:\\ProgramData\\DriveMapper\\DriveMap.ps1
        $base64Script = "${base64Script}"
        $scriptBytes = [System.Convert]::FromBase64String($base64Script)
        $scriptContent = [System.Text.Encoding]::UTF8.GetString($scriptBytes)
        $scriptPath = "$scriptDir\\DriveMap.ps1"
        [System.IO.File]::WriteAllText($scriptPath, $scriptContent)
        Write-Host "Drive mapping script saved to $scriptPath"

        # Create a scheduled task to run the drive mapping script at user logon
        $taskName = "DriveMappingTask"
        $taskDescription = "Runs drive mapping script at user logon"
        $action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-NoProfile -ExecutionPolicy Bypass -File \\"$scriptPath\\""
        $trigger = New-ScheduledTaskTrigger -AtLogOn
        $principal = New-ScheduledTaskPrincipal -GroupId "Users" -RunLevel Limited
        $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable

        # Register the scheduled task
        Register-ScheduledTask -TaskName $taskName -Description $taskDescription -Action $action -Trigger $trigger -Principal $principal -Settings $settings -Force
        Write-Host "Scheduled task '$taskName' created successfully"
    }
    catch {
        Write-Error "Error setting up drive mapping task: $_"
        exit 1
    }
}
else {
    Write-Host "Script not running in SYSTEM context. Please deploy via Intune with SYSTEM context."
}
`;

            // Create and download the Intune script
            const blob = new Blob([intuneScriptContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'IntuneDriveMap.ps1';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
